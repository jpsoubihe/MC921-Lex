Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> global_declaration_list_opt
Rule 2     global_declaration_list_opt -> global_declaration global_declaration_list_opt
Rule 3     global_declaration_list_opt -> empty
Rule 4     global_declaration -> function_definition
Rule 5     global_declaration -> declaration
Rule 6     function_definition -> type_specifier declarator compound_statement
Rule 7     function_definition -> declarator declaration_list_opt compound_statement
Rule 8     declaration_list_opt -> declaration declaration_list_opt
Rule 9     declaration_list_opt -> empty
Rule 10    declarator -> direct_declarator1
Rule 11    direct_declarator1 -> ID
Rule 12    direct_declarator1 -> LPAREN declarator RPAREN
Rule 13    direct_declarator -> direct_declarator LBRACKET constant_expression_opt RBRACKET
Rule 14    direct_declarator -> direct_declarator LPAREN parameter_list RPAREN
Rule 15    direct_declarator -> direct_declarator LPAREN identifier_list_opt RPAREN
Rule 16    constant_expression_opt -> constant_expression
Rule 17    constant_expression_opt -> empty
Rule 18    identifier_list_opt -> ID identifier_list_opt
Rule 19    identifier_list_opt -> empty
Rule 20    constant_expression -> binary_expression
Rule 21    binary_expression -> cast_expression
Rule 22    binary_expression -> binary_expression TIMES binary_expression
Rule 23    binary_expression -> binary_expression DIVIDE binary_expression
Rule 24    binary_expression -> binary_expression MOD binary_expression
Rule 25    binary_expression -> binary_expression PLUS binary_expression
Rule 26    binary_expression -> binary_expression MINUS binary_expression
Rule 27    binary_expression -> binary_expression LT binary_expression
Rule 28    binary_expression -> binary_expression EQUALS binary_expression
Rule 29    binary_expression -> binary_expression EQ binary_expression
Rule 30    binary_expression -> binary_expression LE binary_expression
Rule 31    binary_expression -> binary_expression HT binary_expression
Rule 32    binary_expression -> binary_expression HE binary_expression
Rule 33    binary_expression -> binary_expression DIFF binary_expression
Rule 34    binary_expression -> binary_expression AND binary_expression
Rule 35    binary_expression -> binary_expression OR binary_expression
Rule 36    cast_expression -> unary_expression
Rule 37    cast_expression -> LPAREN type_specifier RPAREN cast_expression
Rule 38    unary_expression -> postfix_expression
Rule 39    unary_expression -> PLUSPLUS unary_expression
Rule 40    unary_expression -> MINUSMINUS unary_expression
Rule 41    unary_expression -> unary_operator cast_expression
Rule 42    postfix_expression -> primary_expression
Rule 43    postfix_expression -> postfix_expression LBRACKET expression RBRACKET
Rule 44    postfix_expression -> postfix_expression LPAREN argument_expression_opt RPAREN
Rule 45    postfix_expression -> postfix_expression PLUSPLUS
Rule 46    postfix_expression -> postfix_expression MINUSMINUS
Rule 47    argument_expression_opt -> argument_expression
Rule 48    argument_expression_opt -> empty
Rule 49    primary_expression -> ID
Rule 50    primary_expression -> constant
Rule 51    primary_expression -> STRING
Rule 52    primary_expression -> LPAREN expression RPAREN
Rule 53    constant -> INT_CONST
Rule 54    constant -> FLOAT_CONST
Rule 55    constant -> CHAR_CONST
Rule 56    expression -> assignment_expression
Rule 57    expression -> expression COMMA assignment_expression
Rule 58    argument_expression -> assignment_expression
Rule 59    argument_expression -> argument_expression COMMA assignment_expression
Rule 60    assignment_expression -> binary_expression
Rule 61    assignment_expression -> unary_expression assignment_operator assignment_expression
Rule 62    assignment_operator -> TIMESASSIGN
Rule 63    assignment_operator -> DIVIDEASSIGN
Rule 64    assignment_operator -> MODASSIGN
Rule 65    assignment_operator -> PLUSASSIGN
Rule 66    assignment_operator -> MINUSASSIGN
Rule 67    unary_operator -> ADDRESS
Rule 68    unary_operator -> TIMES
Rule 69    unary_operator -> PLUS
Rule 70    unary_operator -> MINUS
Rule 71    unary_operator -> UNARYDIFF
Rule 72    type_specifier -> VOID
Rule 73    type_specifier -> CHAR
Rule 74    type_specifier -> INT
Rule 75    type_specifier -> FLOAT
Rule 76    parameter_list -> parameter_declaration
Rule 77    parameter_list -> parameter_list COMMA parameter_declaration
Rule 78    parameter_declaration -> type_specifier declarator
Rule 79    declaration -> type_specifier init_declarator_list_opt SEMI
Rule 80    init_declarator_list_opt -> init_declarator_list
Rule 81    init_declarator_list_opt -> empty
Rule 82    init_declarator_list -> init_declarator
Rule 83    init_declarator_list -> init_declarator_list COMMA init_declarator
Rule 84    init_declarator -> declarator
Rule 85    init_declarator -> declarator EQUALS initializer
Rule 86    initializer -> assignment_expression
Rule 87    initializer -> LBRACE initializer_list RBRACE
Rule 88    initializer -> LBRACE initializer_list COMMA RBRACE
Rule 89    initializer_list -> initializer
Rule 90    initializer_list -> initializer_list COMMA initializer
Rule 91    compound_statement -> LBRACE declaration_list_opt statement_list_opt RBRACE
Rule 92    statement_list_opt -> statement statement_list_opt
Rule 93    statement_list_opt -> empty
Rule 94    statement -> expression_statement
Rule 95    statement -> compound_statement
Rule 96    statement -> selection_statement
Rule 97    statement -> iteration_statement
Rule 98    statement -> jump_statement
Rule 99    statement -> assert_statement
Rule 100   statement -> print_statement
Rule 101   statement -> read_statement
Rule 102   expression_statement -> expression_opt SEMI
Rule 103   expression_opt -> expression
Rule 104   expression_opt -> empty
Rule 105   selection_statement -> IF LPAREN expression RPAREN statement
Rule 106   selection_statement -> IF LPAREN expression RPAREN statement ELSE statement
Rule 107   iteration_statement -> WHILE LPAREN expression RPAREN statement
Rule 108   iteration_statement -> FOR LPAREN init_declarator SEMI expression_opt SEMI expression_opt RPAREN statement
Rule 109   iteration_statement -> FOR LPAREN type_specifier init_declarator SEMI expression_opt SEMI expression_opt RPAREN statement
Rule 110   jump_statement -> BREAK SEMI
Rule 111   jump_statement -> RETURN SEMI
Rule 112   jump_statement -> RETURN expression SEMI
Rule 113   assert_statement -> ASSERT expression SEMI
Rule 114   print_statement -> PRINT LPAREN expression_opt RPAREN SEMI
Rule 115   read_statement -> READ LPAREN argument_expression RPAREN SEMI
Rule 116   empty -> <empty>

Terminals, with rules where they appear

ADDRESS              : 67
AND                  : 34
ASSERT               : 113
BREAK                : 110
CHAR                 : 73
CHAR_CONST           : 55
COMMA                : 57 59 77 83 88 90
DIFF                 : 33
DIVIDE               : 23
DIVIDEASSIGN         : 63
ELSE                 : 106
EQ                   : 29
EQUALS               : 28 85
FLOAT                : 75
FLOAT_CONST          : 54
FOR                  : 108 109
HE                   : 32
HT                   : 31
ID                   : 11 18 49
IF                   : 105 106
INT                  : 74
INT_CONST            : 53
LBRACE               : 87 88 91
LBRACKET             : 13 43
LE                   : 30
LPAREN               : 12 14 15 37 44 52 105 106 107 108 109 114 115
LT                   : 27
MINUS                : 26 70
MINUSASSIGN          : 66
MINUSMINUS           : 40 46
MOD                  : 24
MODASSIGN            : 64
OR                   : 35
PLUS                 : 25 69
PLUSASSIGN           : 65
PLUSPLUS             : 39 45
PRINT                : 114
RBRACE               : 87 88 91
RBRACKET             : 13 43
READ                 : 115
RETURN               : 111 112
RPAREN               : 12 14 15 37 44 52 105 106 107 108 109 114 115
SEMI                 : 79 102 108 108 109 109 110 111 112 113 114 115
STRING               : 51
TIMES                : 22 68
TIMESASSIGN          : 62
UNARYDIFF            : 71
VOID                 : 72
WHILE                : 107
error                : 

Nonterminals, with rules where they appear

argument_expression  : 47 59 115
argument_expression_opt : 44
assert_statement     : 99
assignment_expression : 56 57 58 59 61 86
assignment_operator  : 61
binary_expression    : 20 22 22 23 23 24 24 25 25 26 26 27 27 28 28 29 29 30 30 31 31 32 32 33 33 34 34 35 35 60
cast_expression      : 21 37 41
compound_statement   : 6 7 95
constant             : 50
constant_expression  : 16
constant_expression_opt : 13
declaration          : 5 8
declaration_list_opt : 7 8 91
declarator           : 6 7 12 78 84 85
direct_declarator    : 13 14 15
direct_declarator1   : 10
empty                : 3 9 17 19 48 81 93 104
expression           : 43 52 57 103 105 106 107 112 113
expression_opt       : 102 108 108 109 109 114
expression_statement : 94
function_definition  : 4
global_declaration   : 2
global_declaration_list_opt : 1 2
identifier_list_opt  : 15 18
init_declarator      : 82 83 108 109
init_declarator_list : 80 83
init_declarator_list_opt : 79
initializer          : 85 89 90
initializer_list     : 87 88 90
iteration_statement  : 97
jump_statement       : 98
parameter_declaration : 76 77
parameter_list       : 14 77
postfix_expression   : 38 43 44 45 46
primary_expression   : 42
print_statement      : 100
program              : 0
read_statement       : 101
selection_statement  : 96
statement            : 92 105 106 106 107 108 109
statement_list_opt   : 91 92
type_specifier       : 6 37 78 79 109
unary_expression     : 36 39 40 61
unary_operator       : 41

